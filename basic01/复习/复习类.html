<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>类的基本知识</title>
  <script src="../js/react.development.js"></script>
  <script src="../js/react-dom.development.js"></script>
  <script src="../js/babel.js"></script>
</head>
<body>
  <script type="text/babel">
    /**
     * 总结:
     *  1.类中的构造器不是必须写的，要对实例进行初始化的操作如添加指定属性时才写
     *  2.if a extends b and b has a constructor
     *    则a构造器中super是必须要调用的
     *  3.类中定义的方法其实是放在了类的prototype中 Class.prototype,供类的原型对象上的
     */
    class Person{
       constructor(name,age) {
         //构造器中的this是类的实例对象
         this.name = name;
         this.age = age;
       }
       //类中的一般方法，在其__proto__属性中，供实例使用
       //this是类的实例对象
      speak(){
         console.log(`我叫${this.name},我今年${this.age}岁,我会说话`);
      }
    }
    // let p1 = new Person("jerry",12);
    // let p2 = new Person("andy",15);
    // console.log(p1,p2);
    // p1.speak();
    // p2.speak();
    //p1.speak.call({name:"py",age:18});//更改this指向,此时this是{}
    class Student extends Person{

       constructor(name,age,sno,score) {
         super(name,age);
         this.sno = sno;
         this.score = score;
       }
       //重写从父类继承过来的方法
       speak(){
         super.speak();
         console.log(`我的分数为${this.score}`);
       }
    }


    // let s1 = new Student("小张",13,201813137149,56);
    // console.log(s1);
    // s1.speak();

    class Car{
       //类中可以直接写赋值语句,不需要let var声明关键词
      //此时Car的每个实例都会存在属性a，值为1
       a = 1;
       constructor(name,price) {
         this.name = name;
         this.price = price;
       }
       //prototype上
       // run(){
       //
       // }
       // //放在实例上
       // run = ()=>{
       //   console.log("run");
       // }

        //给类自身上添加属性,相当于Car.demo = 1;类似于java的静态属性
        static demo = 1;
    }
    const c1 = new Car("奔驰c63",12);
    console.log(c1,Car.demo);
  </script>
</body>
</html>
